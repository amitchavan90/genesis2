// Code generated by SQLBoiler 3.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package db

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// Transaction is an object representing the database table.
type Transaction struct {
	ID                 string      `db:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	TrackActionID      string      `db:"track_action_id" boil:"track_action_id" json:"track_action_id" toml:"track_action_id" yaml:"track_action_id"`
	Memo               null.String `db:"memo" boil:"memo" json:"memo,omitempty" toml:"memo" yaml:"memo,omitempty"`
	ProductID          null.String `db:"product_id" boil:"product_id" json:"product_id,omitempty" toml:"product_id" yaml:"product_id,omitempty"`
	CartonID           null.String `db:"carton_id" boil:"carton_id" json:"carton_id,omitempty" toml:"carton_id" yaml:"carton_id,omitempty"`
	ScannedAt          null.Time   `db:"scanned_at" boil:"scanned_at" json:"scanned_at,omitempty" toml:"scanned_at" yaml:"scanned_at,omitempty"`
	LocationGeohash    null.String `db:"location_geohash" boil:"location_geohash" json:"location_geohash,omitempty" toml:"location_geohash" yaml:"location_geohash,omitempty"`
	LocationName       null.String `db:"location_name" boil:"location_name" json:"location_name,omitempty" toml:"location_name" yaml:"location_name,omitempty"`
	ManifestLineJSON   null.String `db:"manifest_line_json" boil:"manifest_line_json" json:"manifest_line_json,omitempty" toml:"manifest_line_json" yaml:"manifest_line_json,omitempty"`
	ManifestLineSha256 null.String `db:"manifest_line_sha256" boil:"manifest_line_sha256" json:"manifest_line_sha256,omitempty" toml:"manifest_line_sha256" yaml:"manifest_line_sha256,omitempty"`
	ManifestID         null.String `db:"manifest_id" boil:"manifest_id" json:"manifest_id,omitempty" toml:"manifest_id" yaml:"manifest_id,omitempty"`
	TransactionHash    null.String `db:"transaction_hash" boil:"transaction_hash" json:"transaction_hash,omitempty" toml:"transaction_hash" yaml:"transaction_hash,omitempty"`
	ProductPhotoBlobID null.String `db:"product_photo_blob_id" boil:"product_photo_blob_id" json:"product_photo_blob_id,omitempty" toml:"product_photo_blob_id" yaml:"product_photo_blob_id,omitempty"`
	CartonPhotoBlobID  null.String `db:"carton_photo_blob_id" boil:"carton_photo_blob_id" json:"carton_photo_blob_id,omitempty" toml:"carton_photo_blob_id" yaml:"carton_photo_blob_id,omitempty"`
	Archived           bool        `db:"archived" boil:"archived" json:"archived" toml:"archived" yaml:"archived"`
	ArchivedAt         null.Time   `db:"archived_at" boil:"archived_at" json:"archived_at,omitempty" toml:"archived_at" yaml:"archived_at,omitempty"`
	UpdatedAt          time.Time   `db:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt          time.Time   `db:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	CreatedByID        null.String `db:"created_by_id" boil:"created_by_id" json:"created_by_id,omitempty" toml:"created_by_id" yaml:"created_by_id,omitempty"`
	CreatedByName      string      `db:"created_by_name" boil:"created_by_name" json:"created_by_name" toml:"created_by_name" yaml:"created_by_name"`

	R *transactionR `db:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L transactionL  `db:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TransactionColumns = struct {
	ID                 string
	TrackActionID      string
	Memo               string
	ProductID          string
	CartonID           string
	ScannedAt          string
	LocationGeohash    string
	LocationName       string
	ManifestLineJSON   string
	ManifestLineSha256 string
	ManifestID         string
	TransactionHash    string
	ProductPhotoBlobID string
	CartonPhotoBlobID  string
	Archived           string
	ArchivedAt         string
	UpdatedAt          string
	CreatedAt          string
	CreatedByID        string
	CreatedByName      string
}{
	ID:                 "id",
	TrackActionID:      "track_action_id",
	Memo:               "memo",
	ProductID:          "product_id",
	CartonID:           "carton_id",
	ScannedAt:          "scanned_at",
	LocationGeohash:    "location_geohash",
	LocationName:       "location_name",
	ManifestLineJSON:   "manifest_line_json",
	ManifestLineSha256: "manifest_line_sha256",
	ManifestID:         "manifest_id",
	TransactionHash:    "transaction_hash",
	ProductPhotoBlobID: "product_photo_blob_id",
	CartonPhotoBlobID:  "carton_photo_blob_id",
	Archived:           "archived",
	ArchivedAt:         "archived_at",
	UpdatedAt:          "updated_at",
	CreatedAt:          "created_at",
	CreatedByID:        "created_by_id",
	CreatedByName:      "created_by_name",
}

// Generated where

var TransactionWhere = struct {
	ID                 whereHelperstring
	TrackActionID      whereHelperstring
	Memo               whereHelpernull_String
	ProductID          whereHelpernull_String
	CartonID           whereHelpernull_String
	ScannedAt          whereHelpernull_Time
	LocationGeohash    whereHelpernull_String
	LocationName       whereHelpernull_String
	ManifestLineJSON   whereHelpernull_String
	ManifestLineSha256 whereHelpernull_String
	ManifestID         whereHelpernull_String
	TransactionHash    whereHelpernull_String
	ProductPhotoBlobID whereHelpernull_String
	CartonPhotoBlobID  whereHelpernull_String
	Archived           whereHelperbool
	ArchivedAt         whereHelpernull_Time
	UpdatedAt          whereHelpertime_Time
	CreatedAt          whereHelpertime_Time
	CreatedByID        whereHelpernull_String
	CreatedByName      whereHelperstring
}{
	ID:                 whereHelperstring{field: "\"transactions\".\"id\""},
	TrackActionID:      whereHelperstring{field: "\"transactions\".\"track_action_id\""},
	Memo:               whereHelpernull_String{field: "\"transactions\".\"memo\""},
	ProductID:          whereHelpernull_String{field: "\"transactions\".\"product_id\""},
	CartonID:           whereHelpernull_String{field: "\"transactions\".\"carton_id\""},
	ScannedAt:          whereHelpernull_Time{field: "\"transactions\".\"scanned_at\""},
	LocationGeohash:    whereHelpernull_String{field: "\"transactions\".\"location_geohash\""},
	LocationName:       whereHelpernull_String{field: "\"transactions\".\"location_name\""},
	ManifestLineJSON:   whereHelpernull_String{field: "\"transactions\".\"manifest_line_json\""},
	ManifestLineSha256: whereHelpernull_String{field: "\"transactions\".\"manifest_line_sha256\""},
	ManifestID:         whereHelpernull_String{field: "\"transactions\".\"manifest_id\""},
	TransactionHash:    whereHelpernull_String{field: "\"transactions\".\"transaction_hash\""},
	ProductPhotoBlobID: whereHelpernull_String{field: "\"transactions\".\"product_photo_blob_id\""},
	CartonPhotoBlobID:  whereHelpernull_String{field: "\"transactions\".\"carton_photo_blob_id\""},
	Archived:           whereHelperbool{field: "\"transactions\".\"archived\""},
	ArchivedAt:         whereHelpernull_Time{field: "\"transactions\".\"archived_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"transactions\".\"updated_at\""},
	CreatedAt:          whereHelpertime_Time{field: "\"transactions\".\"created_at\""},
	CreatedByID:        whereHelpernull_String{field: "\"transactions\".\"created_by_id\""},
	CreatedByName:      whereHelperstring{field: "\"transactions\".\"created_by_name\""},
}

// TransactionRels is where relationship names are stored.
var TransactionRels = struct {
	Carton           string
	CartonPhotoBlob  string
	CreatedBy        string
	Manifest         string
	Product          string
	ProductPhotoBlob string
	TrackAction      string
}{
	Carton:           "Carton",
	CartonPhotoBlob:  "CartonPhotoBlob",
	CreatedBy:        "CreatedBy",
	Manifest:         "Manifest",
	Product:          "Product",
	ProductPhotoBlob: "ProductPhotoBlob",
	TrackAction:      "TrackAction",
}

// transactionR is where relationships are stored.
type transactionR struct {
	Carton           *Carton
	CartonPhotoBlob  *Blob
	CreatedBy        *User
	Manifest         *Manifest
	Product          *Product
	ProductPhotoBlob *Blob
	TrackAction      *TrackAction
}

// NewStruct creates a new relationship struct
func (*transactionR) NewStruct() *transactionR {
	return &transactionR{}
}

// transactionL is where Load methods for each relationship are stored.
type transactionL struct{}

var (
	transactionAllColumns            = []string{"id", "track_action_id", "memo", "product_id", "carton_id", "scanned_at", "location_geohash", "location_name", "manifest_line_json", "manifest_line_sha256", "manifest_id", "transaction_hash", "product_photo_blob_id", "carton_photo_blob_id", "archived", "archived_at", "updated_at", "created_at", "created_by_id", "created_by_name"}
	transactionColumnsWithoutDefault = []string{"track_action_id", "memo", "product_id", "carton_id", "scanned_at", "location_geohash", "location_name", "manifest_line_json", "manifest_line_sha256", "manifest_id", "transaction_hash", "product_photo_blob_id", "carton_photo_blob_id", "archived_at", "created_by_id", "created_by_name"}
	transactionColumnsWithDefault    = []string{"id", "archived", "updated_at", "created_at"}
	transactionPrimaryKeyColumns     = []string{"id"}
)

type (
	// TransactionSlice is an alias for a slice of pointers to Transaction.
	// This should generally be used opposed to []Transaction.
	TransactionSlice []*Transaction
	// TransactionHook is the signature for custom Transaction hook methods
	TransactionHook func(boil.Executor, *Transaction) error

	transactionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	transactionType                 = reflect.TypeOf(&Transaction{})
	transactionMapping              = queries.MakeStructMapping(transactionType)
	transactionPrimaryKeyMapping, _ = queries.BindMapping(transactionType, transactionMapping, transactionPrimaryKeyColumns)
	transactionInsertCacheMut       sync.RWMutex
	transactionInsertCache          = make(map[string]insertCache)
	transactionUpdateCacheMut       sync.RWMutex
	transactionUpdateCache          = make(map[string]updateCache)
	transactionUpsertCacheMut       sync.RWMutex
	transactionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var transactionBeforeInsertHooks []TransactionHook
var transactionBeforeUpdateHooks []TransactionHook
var transactionBeforeDeleteHooks []TransactionHook
var transactionBeforeUpsertHooks []TransactionHook

var transactionAfterInsertHooks []TransactionHook
var transactionAfterSelectHooks []TransactionHook
var transactionAfterUpdateHooks []TransactionHook
var transactionAfterDeleteHooks []TransactionHook
var transactionAfterUpsertHooks []TransactionHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Transaction) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Transaction) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Transaction) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Transaction) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Transaction) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Transaction) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Transaction) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Transaction) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Transaction) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range transactionAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTransactionHook registers your hook function for all future operations.
func AddTransactionHook(hookPoint boil.HookPoint, transactionHook TransactionHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		transactionBeforeInsertHooks = append(transactionBeforeInsertHooks, transactionHook)
	case boil.BeforeUpdateHook:
		transactionBeforeUpdateHooks = append(transactionBeforeUpdateHooks, transactionHook)
	case boil.BeforeDeleteHook:
		transactionBeforeDeleteHooks = append(transactionBeforeDeleteHooks, transactionHook)
	case boil.BeforeUpsertHook:
		transactionBeforeUpsertHooks = append(transactionBeforeUpsertHooks, transactionHook)
	case boil.AfterInsertHook:
		transactionAfterInsertHooks = append(transactionAfterInsertHooks, transactionHook)
	case boil.AfterSelectHook:
		transactionAfterSelectHooks = append(transactionAfterSelectHooks, transactionHook)
	case boil.AfterUpdateHook:
		transactionAfterUpdateHooks = append(transactionAfterUpdateHooks, transactionHook)
	case boil.AfterDeleteHook:
		transactionAfterDeleteHooks = append(transactionAfterDeleteHooks, transactionHook)
	case boil.AfterUpsertHook:
		transactionAfterUpsertHooks = append(transactionAfterUpsertHooks, transactionHook)
	}
}

// One returns a single transaction record from the query.
func (q transactionQuery) One(exec boil.Executor) (*Transaction, error) {
	o := &Transaction{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "db: failed to execute a one query for transactions")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Transaction records from the query.
func (q transactionQuery) All(exec boil.Executor) (TransactionSlice, error) {
	var o []*Transaction

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "db: failed to assign all query results to Transaction slice")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Transaction records in the query.
func (q transactionQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to count transactions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q transactionQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "db: failed to check if transactions exists")
	}

	return count > 0, nil
}

// Carton pointed to by the foreign key.
func (o *Transaction) Carton(mods ...qm.QueryMod) cartonQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CartonID),
	}

	queryMods = append(queryMods, mods...)

	query := Cartons(queryMods...)
	queries.SetFrom(query.Query, "\"cartons\"")

	return query
}

// CartonPhotoBlob pointed to by the foreign key.
func (o *Transaction) CartonPhotoBlob(mods ...qm.QueryMod) blobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CartonPhotoBlobID),
	}

	queryMods = append(queryMods, mods...)

	query := Blobs(queryMods...)
	queries.SetFrom(query.Query, "\"blobs\"")

	return query
}

// CreatedBy pointed to by the foreign key.
func (o *Transaction) CreatedBy(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedByID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Manifest pointed to by the foreign key.
func (o *Transaction) Manifest(mods ...qm.QueryMod) manifestQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ManifestID),
	}

	queryMods = append(queryMods, mods...)

	query := Manifests(queryMods...)
	queries.SetFrom(query.Query, "\"manifests\"")

	return query
}

// Product pointed to by the foreign key.
func (o *Transaction) Product(mods ...qm.QueryMod) productQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	query := Products(queryMods...)
	queries.SetFrom(query.Query, "\"products\"")

	return query
}

// ProductPhotoBlob pointed to by the foreign key.
func (o *Transaction) ProductPhotoBlob(mods ...qm.QueryMod) blobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ProductPhotoBlobID),
	}

	queryMods = append(queryMods, mods...)

	query := Blobs(queryMods...)
	queries.SetFrom(query.Query, "\"blobs\"")

	return query
}

// TrackAction pointed to by the foreign key.
func (o *Transaction) TrackAction(mods ...qm.QueryMod) trackActionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TrackActionID),
	}

	queryMods = append(queryMods, mods...)

	query := TrackActions(queryMods...)
	queries.SetFrom(query.Query, "\"track_actions\"")

	return query
}

// LoadCarton allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadCarton(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.CartonID) {
			args = append(args, object.CartonID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CartonID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CartonID) {
				args = append(args, obj.CartonID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`cartons`), qm.WhereIn(`cartons.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Carton")
	}

	var resultSlice []*Carton
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Carton")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for cartons")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cartons")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Carton = foreign
		if foreign.R == nil {
			foreign.R = &cartonR{}
		}
		foreign.R.Transactions = append(foreign.R.Transactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CartonID, foreign.ID) {
				local.R.Carton = foreign
				if foreign.R == nil {
					foreign.R = &cartonR{}
				}
				foreign.R.Transactions = append(foreign.R.Transactions, local)
				break
			}
		}
	}

	return nil
}

// LoadCartonPhotoBlob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadCartonPhotoBlob(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.CartonPhotoBlobID) {
			args = append(args, object.CartonPhotoBlobID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CartonPhotoBlobID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CartonPhotoBlobID) {
				args = append(args, obj.CartonPhotoBlobID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`blobs`), qm.WhereIn(`blobs.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Blob")
	}

	var resultSlice []*Blob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Blob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blobs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blobs")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CartonPhotoBlob = foreign
		if foreign.R == nil {
			foreign.R = &blobR{}
		}
		foreign.R.CartonPhotoBlobTransactions = append(foreign.R.CartonPhotoBlobTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CartonPhotoBlobID, foreign.ID) {
				local.R.CartonPhotoBlob = foreign
				if foreign.R == nil {
					foreign.R = &blobR{}
				}
				foreign.R.CartonPhotoBlobTransactions = append(foreign.R.CartonPhotoBlobTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadCreatedBy(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.CreatedByID) {
			args = append(args, object.CreatedByID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CreatedByID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CreatedByID) {
				args = append(args, obj.CreatedByID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`users`), qm.WhereIn(`users.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedBy = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByTransactions = append(foreign.R.CreatedByTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatedByID, foreign.ID) {
				local.R.CreatedBy = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByTransactions = append(foreign.R.CreatedByTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadManifest allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadManifest(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.ManifestID) {
			args = append(args, object.ManifestID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ManifestID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ManifestID) {
				args = append(args, obj.ManifestID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`manifests`), qm.WhereIn(`manifests.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Manifest")
	}

	var resultSlice []*Manifest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Manifest")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for manifests")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for manifests")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Manifest = foreign
		if foreign.R == nil {
			foreign.R = &manifestR{}
		}
		foreign.R.Transactions = append(foreign.R.Transactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ManifestID, foreign.ID) {
				local.R.Manifest = foreign
				if foreign.R == nil {
					foreign.R = &manifestR{}
				}
				foreign.R.Transactions = append(foreign.R.Transactions, local)
				break
			}
		}
	}

	return nil
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadProduct(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.ProductID) {
			args = append(args, object.ProductID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductID) {
				args = append(args, obj.ProductID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`products`), qm.WhereIn(`products.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Product")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for products")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &productR{}
		}
		foreign.R.Transactions = append(foreign.R.Transactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductID, foreign.ID) {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.Transactions = append(foreign.R.Transactions, local)
				break
			}
		}
	}

	return nil
}

// LoadProductPhotoBlob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadProductPhotoBlob(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		if !queries.IsNil(object.ProductPhotoBlobID) {
			args = append(args, object.ProductPhotoBlobID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductPhotoBlobID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductPhotoBlobID) {
				args = append(args, obj.ProductPhotoBlobID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`blobs`), qm.WhereIn(`blobs.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Blob")
	}

	var resultSlice []*Blob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Blob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blobs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blobs")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductPhotoBlob = foreign
		if foreign.R == nil {
			foreign.R = &blobR{}
		}
		foreign.R.ProductPhotoBlobTransactions = append(foreign.R.ProductPhotoBlobTransactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductPhotoBlobID, foreign.ID) {
				local.R.ProductPhotoBlob = foreign
				if foreign.R == nil {
					foreign.R = &blobR{}
				}
				foreign.R.ProductPhotoBlobTransactions = append(foreign.R.ProductPhotoBlobTransactions, local)
				break
			}
		}
	}

	return nil
}

// LoadTrackAction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (transactionL) LoadTrackAction(e boil.Executor, singular bool, maybeTransaction interface{}, mods queries.Applicator) error {
	var slice []*Transaction
	var object *Transaction

	if singular {
		object = maybeTransaction.(*Transaction)
	} else {
		slice = *maybeTransaction.(*[]*Transaction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &transactionR{}
		}
		args = append(args, object.TrackActionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &transactionR{}
			}

			for _, a := range args {
				if a == obj.TrackActionID {
					continue Outer
				}
			}

			args = append(args, obj.TrackActionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`track_actions`), qm.WhereIn(`track_actions.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TrackAction")
	}

	var resultSlice []*TrackAction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TrackAction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for track_actions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for track_actions")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TrackAction = foreign
		if foreign.R == nil {
			foreign.R = &trackActionR{}
		}
		foreign.R.Transactions = append(foreign.R.Transactions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TrackActionID == foreign.ID {
				local.R.TrackAction = foreign
				if foreign.R == nil {
					foreign.R = &trackActionR{}
				}
				foreign.R.Transactions = append(foreign.R.Transactions, local)
				break
			}
		}
	}

	return nil
}

// SetCarton of the transaction to the related item.
// Sets o.R.Carton to related.
// Adds o to related.R.Transactions.
func (o *Transaction) SetCarton(exec boil.Executor, insert bool, related *Carton) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"carton_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CartonID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			Carton: related,
		}
	} else {
		o.R.Carton = related
	}

	if related.R == nil {
		related.R = &cartonR{
			Transactions: TransactionSlice{o},
		}
	} else {
		related.R.Transactions = append(related.R.Transactions, o)
	}

	return nil
}

// RemoveCarton relationship.
// Sets o.R.Carton to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveCarton(exec boil.Executor, related *Carton) error {
	var err error

	queries.SetScanner(&o.CartonID, nil)
	if _, err = o.Update(exec, boil.Whitelist("carton_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Carton = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Transactions {
		if queries.Equal(o.CartonID, ri.CartonID) {
			continue
		}

		ln := len(related.R.Transactions)
		if ln > 1 && i < ln-1 {
			related.R.Transactions[i] = related.R.Transactions[ln-1]
		}
		related.R.Transactions = related.R.Transactions[:ln-1]
		break
	}
	return nil
}

// SetCartonPhotoBlob of the transaction to the related item.
// Sets o.R.CartonPhotoBlob to related.
// Adds o to related.R.CartonPhotoBlobTransactions.
func (o *Transaction) SetCartonPhotoBlob(exec boil.Executor, insert bool, related *Blob) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"carton_photo_blob_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CartonPhotoBlobID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			CartonPhotoBlob: related,
		}
	} else {
		o.R.CartonPhotoBlob = related
	}

	if related.R == nil {
		related.R = &blobR{
			CartonPhotoBlobTransactions: TransactionSlice{o},
		}
	} else {
		related.R.CartonPhotoBlobTransactions = append(related.R.CartonPhotoBlobTransactions, o)
	}

	return nil
}

// RemoveCartonPhotoBlob relationship.
// Sets o.R.CartonPhotoBlob to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveCartonPhotoBlob(exec boil.Executor, related *Blob) error {
	var err error

	queries.SetScanner(&o.CartonPhotoBlobID, nil)
	if _, err = o.Update(exec, boil.Whitelist("carton_photo_blob_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CartonPhotoBlob = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CartonPhotoBlobTransactions {
		if queries.Equal(o.CartonPhotoBlobID, ri.CartonPhotoBlobID) {
			continue
		}

		ln := len(related.R.CartonPhotoBlobTransactions)
		if ln > 1 && i < ln-1 {
			related.R.CartonPhotoBlobTransactions[i] = related.R.CartonPhotoBlobTransactions[ln-1]
		}
		related.R.CartonPhotoBlobTransactions = related.R.CartonPhotoBlobTransactions[:ln-1]
		break
	}
	return nil
}

// SetCreatedBy of the transaction to the related item.
// Sets o.R.CreatedBy to related.
// Adds o to related.R.CreatedByTransactions.
func (o *Transaction) SetCreatedBy(exec boil.Executor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatedByID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			CreatedBy: related,
		}
	} else {
		o.R.CreatedBy = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByTransactions: TransactionSlice{o},
		}
	} else {
		related.R.CreatedByTransactions = append(related.R.CreatedByTransactions, o)
	}

	return nil
}

// RemoveCreatedBy relationship.
// Sets o.R.CreatedBy to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveCreatedBy(exec boil.Executor, related *User) error {
	var err error

	queries.SetScanner(&o.CreatedByID, nil)
	if _, err = o.Update(exec, boil.Whitelist("created_by_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CreatedBy = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatedByTransactions {
		if queries.Equal(o.CreatedByID, ri.CreatedByID) {
			continue
		}

		ln := len(related.R.CreatedByTransactions)
		if ln > 1 && i < ln-1 {
			related.R.CreatedByTransactions[i] = related.R.CreatedByTransactions[ln-1]
		}
		related.R.CreatedByTransactions = related.R.CreatedByTransactions[:ln-1]
		break
	}
	return nil
}

// SetManifest of the transaction to the related item.
// Sets o.R.Manifest to related.
// Adds o to related.R.Transactions.
func (o *Transaction) SetManifest(exec boil.Executor, insert bool, related *Manifest) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"manifest_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ManifestID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			Manifest: related,
		}
	} else {
		o.R.Manifest = related
	}

	if related.R == nil {
		related.R = &manifestR{
			Transactions: TransactionSlice{o},
		}
	} else {
		related.R.Transactions = append(related.R.Transactions, o)
	}

	return nil
}

// RemoveManifest relationship.
// Sets o.R.Manifest to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveManifest(exec boil.Executor, related *Manifest) error {
	var err error

	queries.SetScanner(&o.ManifestID, nil)
	if _, err = o.Update(exec, boil.Whitelist("manifest_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Manifest = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Transactions {
		if queries.Equal(o.ManifestID, ri.ManifestID) {
			continue
		}

		ln := len(related.R.Transactions)
		if ln > 1 && i < ln-1 {
			related.R.Transactions[i] = related.R.Transactions[ln-1]
		}
		related.R.Transactions = related.R.Transactions[:ln-1]
		break
	}
	return nil
}

// SetProduct of the transaction to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.Transactions.
func (o *Transaction) SetProduct(exec boil.Executor, insert bool, related *Product) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"product_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &productR{
			Transactions: TransactionSlice{o},
		}
	} else {
		related.R.Transactions = append(related.R.Transactions, o)
	}

	return nil
}

// RemoveProduct relationship.
// Sets o.R.Product to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveProduct(exec boil.Executor, related *Product) error {
	var err error

	queries.SetScanner(&o.ProductID, nil)
	if _, err = o.Update(exec, boil.Whitelist("product_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Product = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Transactions {
		if queries.Equal(o.ProductID, ri.ProductID) {
			continue
		}

		ln := len(related.R.Transactions)
		if ln > 1 && i < ln-1 {
			related.R.Transactions[i] = related.R.Transactions[ln-1]
		}
		related.R.Transactions = related.R.Transactions[:ln-1]
		break
	}
	return nil
}

// SetProductPhotoBlob of the transaction to the related item.
// Sets o.R.ProductPhotoBlob to related.
// Adds o to related.R.ProductPhotoBlobTransactions.
func (o *Transaction) SetProductPhotoBlob(exec boil.Executor, insert bool, related *Blob) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"product_photo_blob_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductPhotoBlobID, related.ID)
	if o.R == nil {
		o.R = &transactionR{
			ProductPhotoBlob: related,
		}
	} else {
		o.R.ProductPhotoBlob = related
	}

	if related.R == nil {
		related.R = &blobR{
			ProductPhotoBlobTransactions: TransactionSlice{o},
		}
	} else {
		related.R.ProductPhotoBlobTransactions = append(related.R.ProductPhotoBlobTransactions, o)
	}

	return nil
}

// RemoveProductPhotoBlob relationship.
// Sets o.R.ProductPhotoBlob to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Transaction) RemoveProductPhotoBlob(exec boil.Executor, related *Blob) error {
	var err error

	queries.SetScanner(&o.ProductPhotoBlobID, nil)
	if _, err = o.Update(exec, boil.Whitelist("product_photo_blob_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductPhotoBlob = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProductPhotoBlobTransactions {
		if queries.Equal(o.ProductPhotoBlobID, ri.ProductPhotoBlobID) {
			continue
		}

		ln := len(related.R.ProductPhotoBlobTransactions)
		if ln > 1 && i < ln-1 {
			related.R.ProductPhotoBlobTransactions[i] = related.R.ProductPhotoBlobTransactions[ln-1]
		}
		related.R.ProductPhotoBlobTransactions = related.R.ProductPhotoBlobTransactions[:ln-1]
		break
	}
	return nil
}

// SetTrackAction of the transaction to the related item.
// Sets o.R.TrackAction to related.
// Adds o to related.R.Transactions.
func (o *Transaction) SetTrackAction(exec boil.Executor, insert bool, related *TrackAction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"track_action_id"}),
		strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TrackActionID = related.ID
	if o.R == nil {
		o.R = &transactionR{
			TrackAction: related,
		}
	} else {
		o.R.TrackAction = related
	}

	if related.R == nil {
		related.R = &trackActionR{
			Transactions: TransactionSlice{o},
		}
	} else {
		related.R.Transactions = append(related.R.Transactions, o)
	}

	return nil
}

// Transactions retrieves all the records using an executor.
func Transactions(mods ...qm.QueryMod) transactionQuery {
	mods = append(mods, qm.From("\"transactions\""))
	return transactionQuery{NewQuery(mods...)}
}

// FindTransaction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTransaction(exec boil.Executor, iD string, selectCols ...string) (*Transaction, error) {
	transactionObj := &Transaction{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"transactions\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, transactionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "db: unable to select from transactions")
	}

	return transactionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Transaction) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("db: no transactions provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	transactionInsertCacheMut.RLock()
	cache, cached := transactionInsertCache[key]
	transactionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			transactionAllColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"transactions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"transactions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "db: unable to insert into transactions")
	}

	if !cached {
		transactionInsertCacheMut.Lock()
		transactionInsertCache[key] = cache
		transactionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Transaction.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Transaction) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	transactionUpdateCacheMut.RLock()
	cache, cached := transactionUpdateCache[key]
	transactionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			transactionAllColumns,
			transactionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("db: unable to update transactions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"transactions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, transactionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, append(wl, transactionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update transactions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by update for transactions")
	}

	if !cached {
		transactionUpdateCacheMut.Lock()
		transactionUpdateCache[key] = cache
		transactionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q transactionQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update all for transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to retrieve rows affected for transactions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TransactionSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("db: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"transactions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, transactionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update all in transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to retrieve rows affected all in update all transaction")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Transaction) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("db: no transactions provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(transactionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	transactionUpsertCacheMut.RLock()
	cache, cached := transactionUpsertCache[key]
	transactionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			transactionAllColumns,
			transactionColumnsWithDefault,
			transactionColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			transactionAllColumns,
			transactionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("db: unable to upsert transactions, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(transactionPrimaryKeyColumns))
			copy(conflict, transactionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"transactions\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(transactionType, transactionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(transactionType, transactionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "db: unable to upsert transactions")
	}

	if !cached {
		transactionUpsertCacheMut.Lock()
		transactionUpsertCache[key] = cache
		transactionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Transaction record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Transaction) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("db: no Transaction provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), transactionPrimaryKeyMapping)
	sql := "DELETE FROM \"transactions\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete from transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by delete for transactions")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q transactionQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("db: no transactionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete all from transactions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by deleteall for transactions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TransactionSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(transactionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, transactionPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete all from transaction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by deleteall for transactions")
	}

	if len(transactionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Transaction) Reload(exec boil.Executor) error {
	ret, err := FindTransaction(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TransactionSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TransactionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), transactionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"transactions\".* FROM \"transactions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, transactionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "db: unable to reload all in TransactionSlice")
	}

	*o = slice

	return nil
}

// TransactionExists checks if the Transaction row exists.
func TransactionExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"transactions\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "db: unable to check if transactions exists")
	}

	return exists, nil
}
