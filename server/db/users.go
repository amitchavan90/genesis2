// Code generated by SQLBoiler 3.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package db

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID                 string      `db:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	OrganisationID     null.String `db:"organisation_id" boil:"organisation_id" json:"organisation_id,omitempty" toml:"organisation_id" yaml:"organisation_id,omitempty"`
	RoleID             string      `db:"role_id" boil:"role_id" json:"role_id" toml:"role_id" yaml:"role_id"`
	Email              null.String `db:"email" boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	FirstName          null.String `db:"first_name" boil:"first_name" json:"first_name,omitempty" toml:"first_name" yaml:"first_name,omitempty"`
	LastName           null.String `db:"last_name" boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	AffiliateOrg       null.String `db:"affiliate_org" boil:"affiliate_org" json:"affiliate_org,omitempty" toml:"affiliate_org" yaml:"affiliate_org,omitempty"`
	ReferralCode       null.String `db:"referral_code" boil:"referral_code" json:"referral_code,omitempty" toml:"referral_code" yaml:"referral_code,omitempty"`
	MobilePhone        null.String `db:"mobile_phone" boil:"mobile_phone" json:"mobile_phone,omitempty" toml:"mobile_phone" yaml:"mobile_phone,omitempty"`
	MobileVerified     bool        `db:"mobile_verified" boil:"mobile_verified" json:"mobile_verified" toml:"mobile_verified" yaml:"mobile_verified"`
	WechatID           null.String `db:"wechat_id" boil:"wechat_id" json:"wechat_id,omitempty" toml:"wechat_id" yaml:"wechat_id,omitempty"`
	Verified           bool        `db:"verified" boil:"verified" json:"verified" toml:"verified" yaml:"verified"`
	VerifyToken        string      `db:"verify_token" boil:"verify_token" json:"verify_token" toml:"verify_token" yaml:"verify_token"`
	VerifyTokenExpires time.Time   `db:"verify_token_expires" boil:"verify_token_expires" json:"verify_token_expires" toml:"verify_token_expires" yaml:"verify_token_expires"`
	ResetToken         string      `db:"reset_token" boil:"reset_token" json:"reset_token" toml:"reset_token" yaml:"reset_token"`
	ResetTokenExpires  time.Time   `db:"reset_token_expires" boil:"reset_token_expires" json:"reset_token_expires" toml:"reset_token_expires" yaml:"reset_token_expires"`
	PasswordHash       string      `db:"password_hash" boil:"password_hash" json:"password_hash" toml:"password_hash" yaml:"password_hash"`
	Archived           bool        `db:"archived" boil:"archived" json:"archived" toml:"archived" yaml:"archived"`
	ArchivedAt         null.Time   `db:"archived_at" boil:"archived_at" json:"archived_at,omitempty" toml:"archived_at" yaml:"archived_at,omitempty"`
	UpdatedAt          time.Time   `db:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt          time.Time   `db:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *userR `db:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `db:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                 string
	OrganisationID     string
	RoleID             string
	Email              string
	FirstName          string
	LastName           string
	AffiliateOrg       string
	ReferralCode       string
	MobilePhone        string
	MobileVerified     string
	WechatID           string
	Verified           string
	VerifyToken        string
	VerifyTokenExpires string
	ResetToken         string
	ResetTokenExpires  string
	PasswordHash       string
	Archived           string
	ArchivedAt         string
	UpdatedAt          string
	CreatedAt          string
}{
	ID:                 "id",
	OrganisationID:     "organisation_id",
	RoleID:             "role_id",
	Email:              "email",
	FirstName:          "first_name",
	LastName:           "last_name",
	AffiliateOrg:       "affiliate_org",
	ReferralCode:       "referral_code",
	MobilePhone:        "mobile_phone",
	MobileVerified:     "mobile_verified",
	WechatID:           "wechat_id",
	Verified:           "verified",
	VerifyToken:        "verify_token",
	VerifyTokenExpires: "verify_token_expires",
	ResetToken:         "reset_token",
	ResetTokenExpires:  "reset_token_expires",
	PasswordHash:       "password_hash",
	Archived:           "archived",
	ArchivedAt:         "archived_at",
	UpdatedAt:          "updated_at",
	CreatedAt:          "created_at",
}

// Generated where

var UserWhere = struct {
	ID                 whereHelperstring
	OrganisationID     whereHelpernull_String
	RoleID             whereHelperstring
	Email              whereHelpernull_String
	FirstName          whereHelpernull_String
	LastName           whereHelpernull_String
	AffiliateOrg       whereHelpernull_String
	ReferralCode       whereHelpernull_String
	MobilePhone        whereHelpernull_String
	MobileVerified     whereHelperbool
	WechatID           whereHelpernull_String
	Verified           whereHelperbool
	VerifyToken        whereHelperstring
	VerifyTokenExpires whereHelpertime_Time
	ResetToken         whereHelperstring
	ResetTokenExpires  whereHelpertime_Time
	PasswordHash       whereHelperstring
	Archived           whereHelperbool
	ArchivedAt         whereHelpernull_Time
	UpdatedAt          whereHelpertime_Time
	CreatedAt          whereHelpertime_Time
}{
	ID:                 whereHelperstring{field: "\"users\".\"id\""},
	OrganisationID:     whereHelpernull_String{field: "\"users\".\"organisation_id\""},
	RoleID:             whereHelperstring{field: "\"users\".\"role_id\""},
	Email:              whereHelpernull_String{field: "\"users\".\"email\""},
	FirstName:          whereHelpernull_String{field: "\"users\".\"first_name\""},
	LastName:           whereHelpernull_String{field: "\"users\".\"last_name\""},
	AffiliateOrg:       whereHelpernull_String{field: "\"users\".\"affiliate_org\""},
	ReferralCode:       whereHelpernull_String{field: "\"users\".\"referral_code\""},
	MobilePhone:        whereHelpernull_String{field: "\"users\".\"mobile_phone\""},
	MobileVerified:     whereHelperbool{field: "\"users\".\"mobile_verified\""},
	WechatID:           whereHelpernull_String{field: "\"users\".\"wechat_id\""},
	Verified:           whereHelperbool{field: "\"users\".\"verified\""},
	VerifyToken:        whereHelperstring{field: "\"users\".\"verify_token\""},
	VerifyTokenExpires: whereHelpertime_Time{field: "\"users\".\"verify_token_expires\""},
	ResetToken:         whereHelperstring{field: "\"users\".\"reset_token\""},
	ResetTokenExpires:  whereHelpertime_Time{field: "\"users\".\"reset_token_expires\""},
	PasswordHash:       whereHelperstring{field: "\"users\".\"password_hash\""},
	Archived:           whereHelperbool{field: "\"users\".\"archived\""},
	ArchivedAt:         whereHelpernull_Time{field: "\"users\".\"archived_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"users\".\"updated_at\""},
	CreatedAt:          whereHelpertime_Time{field: "\"users\".\"created_at\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	Organisation               string
	Role                       string
	CreatedByCartons           string
	CreatedByContainers        string
	CreatedByContracts         string
	CreatedByDistributors      string
	IssuedTokens               string
	CreatedByOrders            string
	CreatedByPallets           string
	CreatedByProducts          string
	ReferredByReferrals        string
	Referrals                  string
	CreatedByStockKeepingUnits string
	CreatedByTrackActions      string
	CreatedByTransactions      string
	UserActivities             string
	UserLoyaltyActivities      string
	UserTasks                  string
}{
	Organisation:               "Organisation",
	Role:                       "Role",
	CreatedByCartons:           "CreatedByCartons",
	CreatedByContainers:        "CreatedByContainers",
	CreatedByContracts:         "CreatedByContracts",
	CreatedByDistributors:      "CreatedByDistributors",
	IssuedTokens:               "IssuedTokens",
	CreatedByOrders:            "CreatedByOrders",
	CreatedByPallets:           "CreatedByPallets",
	CreatedByProducts:          "CreatedByProducts",
	ReferredByReferrals:        "ReferredByReferrals",
	Referrals:                  "Referrals",
	CreatedByStockKeepingUnits: "CreatedByStockKeepingUnits",
	CreatedByTrackActions:      "CreatedByTrackActions",
	CreatedByTransactions:      "CreatedByTransactions",
	UserActivities:             "UserActivities",
	UserLoyaltyActivities:      "UserLoyaltyActivities",
	UserTasks:                  "UserTasks",
}

// userR is where relationships are stored.
type userR struct {
	Organisation               *Organisation
	Role                       *Role
	CreatedByCartons           CartonSlice
	CreatedByContainers        ContainerSlice
	CreatedByContracts         ContractSlice
	CreatedByDistributors      DistributorSlice
	IssuedTokens               IssuedTokenSlice
	CreatedByOrders            OrderSlice
	CreatedByPallets           PalletSlice
	CreatedByProducts          ProductSlice
	ReferredByReferrals        ReferralSlice
	Referrals                  ReferralSlice
	CreatedByStockKeepingUnits StockKeepingUnitSlice
	CreatedByTrackActions      TrackActionSlice
	CreatedByTransactions      TransactionSlice
	UserActivities             UserActivitySlice
	UserLoyaltyActivities      UserLoyaltyActivitySlice
	UserTasks                  UserTaskSlice
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "organisation_id", "role_id", "email", "first_name", "last_name", "affiliate_org", "referral_code", "mobile_phone", "mobile_verified", "wechat_id", "verified", "verify_token", "verify_token_expires", "reset_token", "reset_token_expires", "password_hash", "archived", "archived_at", "updated_at", "created_at"}
	userColumnsWithoutDefault = []string{"organisation_id", "role_id", "email", "first_name", "last_name", "affiliate_org", "referral_code", "mobile_phone", "wechat_id", "password_hash", "archived_at"}
	userColumnsWithDefault    = []string{"id", "mobile_verified", "verified", "verify_token", "verify_token_expires", "reset_token", "reset_token_expires", "archived", "updated_at", "created_at"}
	userPrimaryKeyColumns     = []string{"id"}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should generally be used opposed to []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(boil.Executor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userBeforeInsertHooks []UserHook
var userBeforeUpdateHooks []UserHook
var userBeforeDeleteHooks []UserHook
var userBeforeUpsertHooks []UserHook

var userAfterInsertHooks []UserHook
var userAfterSelectHooks []UserHook
var userAfterUpdateHooks []UserHook
var userAfterDeleteHooks []UserHook
var userAfterUpsertHooks []UserHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range userBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range userBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range userBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range userBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range userAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range userAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range userAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range userAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range userAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
	case boil.BeforeUpdateHook:
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
	case boil.BeforeDeleteHook:
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
	case boil.BeforeUpsertHook:
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
	case boil.AfterInsertHook:
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
	case boil.AfterSelectHook:
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
	case boil.AfterUpdateHook:
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
	case boil.AfterDeleteHook:
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
	case boil.AfterUpsertHook:
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
	}
}

// One returns a single user record from the query.
func (q userQuery) One(exec boil.Executor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "db: failed to execute a one query for users")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(exec boil.Executor) (UserSlice, error) {
	var o []*User

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "db: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "db: failed to check if users exists")
	}

	return count > 0, nil
}

// Organisation pointed to by the foreign key.
func (o *User) Organisation(mods ...qm.QueryMod) organisationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OrganisationID),
	}

	queryMods = append(queryMods, mods...)

	query := Organisations(queryMods...)
	queries.SetFrom(query.Query, "\"organisations\"")

	return query
}

// Role pointed to by the foreign key.
func (o *User) Role(mods ...qm.QueryMod) roleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RoleID),
	}

	queryMods = append(queryMods, mods...)

	query := Roles(queryMods...)
	queries.SetFrom(query.Query, "\"roles\"")

	return query
}

// CreatedByCartons retrieves all the carton's Cartons with an executor via created_by_id column.
func (o *User) CreatedByCartons(mods ...qm.QueryMod) cartonQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"cartons\".\"created_by_id\"=?", o.ID),
	)

	query := Cartons(queryMods...)
	queries.SetFrom(query.Query, "\"cartons\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"cartons\".*"})
	}

	return query
}

// CreatedByContainers retrieves all the container's Containers with an executor via created_by_id column.
func (o *User) CreatedByContainers(mods ...qm.QueryMod) containerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"containers\".\"created_by_id\"=?", o.ID),
	)

	query := Containers(queryMods...)
	queries.SetFrom(query.Query, "\"containers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"containers\".*"})
	}

	return query
}

// CreatedByContracts retrieves all the contract's Contracts with an executor via created_by_id column.
func (o *User) CreatedByContracts(mods ...qm.QueryMod) contractQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"contracts\".\"created_by_id\"=?", o.ID),
	)

	query := Contracts(queryMods...)
	queries.SetFrom(query.Query, "\"contracts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"contracts\".*"})
	}

	return query
}

// CreatedByDistributors retrieves all the distributor's Distributors with an executor via created_by_id column.
func (o *User) CreatedByDistributors(mods ...qm.QueryMod) distributorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"distributors\".\"created_by_id\"=?", o.ID),
	)

	query := Distributors(queryMods...)
	queries.SetFrom(query.Query, "\"distributors\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"distributors\".*"})
	}

	return query
}

// IssuedTokens retrieves all the issued_token's IssuedTokens with an executor.
func (o *User) IssuedTokens(mods ...qm.QueryMod) issuedTokenQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"issued_tokens\".\"user_id\"=?", o.ID),
	)

	query := IssuedTokens(queryMods...)
	queries.SetFrom(query.Query, "\"issued_tokens\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"issued_tokens\".*"})
	}

	return query
}

// CreatedByOrders retrieves all the order's Orders with an executor via created_by_id column.
func (o *User) CreatedByOrders(mods ...qm.QueryMod) orderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orders\".\"created_by_id\"=?", o.ID),
	)

	query := Orders(queryMods...)
	queries.SetFrom(query.Query, "\"orders\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"orders\".*"})
	}

	return query
}

// CreatedByPallets retrieves all the pallet's Pallets with an executor via created_by_id column.
func (o *User) CreatedByPallets(mods ...qm.QueryMod) palletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"pallets\".\"created_by_id\"=?", o.ID),
	)

	query := Pallets(queryMods...)
	queries.SetFrom(query.Query, "\"pallets\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"pallets\".*"})
	}

	return query
}

// CreatedByProducts retrieves all the product's Products with an executor via created_by_id column.
func (o *User) CreatedByProducts(mods ...qm.QueryMod) productQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"products\".\"created_by_id\"=?", o.ID),
	)

	query := Products(queryMods...)
	queries.SetFrom(query.Query, "\"products\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"products\".*"})
	}

	return query
}

// ReferredByReferrals retrieves all the referral's Referrals with an executor via referred_by_id column.
func (o *User) ReferredByReferrals(mods ...qm.QueryMod) referralQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referrals\".\"referred_by_id\"=?", o.ID),
	)

	query := Referrals(queryMods...)
	queries.SetFrom(query.Query, "\"referrals\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referrals\".*"})
	}

	return query
}

// Referrals retrieves all the referral's Referrals with an executor.
func (o *User) Referrals(mods ...qm.QueryMod) referralQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"referrals\".\"user_id\"=?", o.ID),
	)

	query := Referrals(queryMods...)
	queries.SetFrom(query.Query, "\"referrals\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"referrals\".*"})
	}

	return query
}

// CreatedByStockKeepingUnits retrieves all the stock_keeping_unit's StockKeepingUnits with an executor via created_by_id column.
func (o *User) CreatedByStockKeepingUnits(mods ...qm.QueryMod) stockKeepingUnitQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"stock_keeping_units\".\"created_by_id\"=?", o.ID),
	)

	query := StockKeepingUnits(queryMods...)
	queries.SetFrom(query.Query, "\"stock_keeping_units\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"stock_keeping_units\".*"})
	}

	return query
}

// CreatedByTrackActions retrieves all the track_action's TrackActions with an executor via created_by_id column.
func (o *User) CreatedByTrackActions(mods ...qm.QueryMod) trackActionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"track_actions\".\"created_by_id\"=?", o.ID),
	)

	query := TrackActions(queryMods...)
	queries.SetFrom(query.Query, "\"track_actions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"track_actions\".*"})
	}

	return query
}

// CreatedByTransactions retrieves all the transaction's Transactions with an executor via created_by_id column.
func (o *User) CreatedByTransactions(mods ...qm.QueryMod) transactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transactions\".\"created_by_id\"=?", o.ID),
	)

	query := Transactions(queryMods...)
	queries.SetFrom(query.Query, "\"transactions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"transactions\".*"})
	}

	return query
}

// UserActivities retrieves all the user_activity's UserActivities with an executor.
func (o *User) UserActivities(mods ...qm.QueryMod) userActivityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_activities\".\"user_id\"=?", o.ID),
	)

	query := UserActivities(queryMods...)
	queries.SetFrom(query.Query, "\"user_activities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_activities\".*"})
	}

	return query
}

// UserLoyaltyActivities retrieves all the user_loyalty_activity's UserLoyaltyActivities with an executor.
func (o *User) UserLoyaltyActivities(mods ...qm.QueryMod) userLoyaltyActivityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_loyalty_activities\".\"user_id\"=?", o.ID),
	)

	query := UserLoyaltyActivities(queryMods...)
	queries.SetFrom(query.Query, "\"user_loyalty_activities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_loyalty_activities\".*"})
	}

	return query
}

// UserTasks retrieves all the user_task's UserTasks with an executor.
func (o *User) UserTasks(mods ...qm.QueryMod) userTaskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_tasks\".\"user_id\"=?", o.ID),
	)

	query := UserTasks(queryMods...)
	queries.SetFrom(query.Query, "\"user_tasks\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_tasks\".*"})
	}

	return query
}

// LoadOrganisation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadOrganisation(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.OrganisationID) {
			args = append(args, object.OrganisationID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrganisationID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrganisationID) {
				args = append(args, obj.OrganisationID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`organisations`), qm.WhereIn(`organisations.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Organisation")
	}

	var resultSlice []*Organisation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Organisation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for organisations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for organisations")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Organisation = foreign
		if foreign.R == nil {
			foreign.R = &organisationR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrganisationID, foreign.ID) {
				local.R.Organisation = foreign
				if foreign.R == nil {
					foreign.R = &organisationR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadRole allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadRole(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.RoleID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.RoleID {
					continue Outer
				}
			}

			args = append(args, obj.RoleID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`roles`), qm.WhereIn(`roles.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Role")
	}

	var resultSlice []*Role
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Role")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for roles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for roles")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Role = foreign
		if foreign.R == nil {
			foreign.R = &roleR{}
		}
		foreign.R.Users = append(foreign.R.Users, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RoleID == foreign.ID {
				local.R.Role = foreign
				if foreign.R == nil {
					foreign.R = &roleR{}
				}
				foreign.R.Users = append(foreign.R.Users, local)
				break
			}
		}
	}

	return nil
}

// LoadCreatedByCartons allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByCartons(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`cartons`), qm.WhereIn(`cartons.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load cartons")
	}

	var resultSlice []*Carton
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice cartons")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on cartons")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cartons")
	}

	if len(cartonAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByCartons = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cartonR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByCartons = append(local.R.CreatedByCartons, foreign)
				if foreign.R == nil {
					foreign.R = &cartonR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByContainers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByContainers(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`containers`), qm.WhereIn(`containers.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load containers")
	}

	var resultSlice []*Container
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice containers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on containers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for containers")
	}

	if len(containerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByContainers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &containerR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByContainers = append(local.R.CreatedByContainers, foreign)
				if foreign.R == nil {
					foreign.R = &containerR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByContracts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByContracts(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`contracts`), qm.WhereIn(`contracts.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load contracts")
	}

	var resultSlice []*Contract
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice contracts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on contracts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for contracts")
	}

	if len(contractAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByContracts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &contractR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByContracts = append(local.R.CreatedByContracts, foreign)
				if foreign.R == nil {
					foreign.R = &contractR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByDistributors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByDistributors(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`distributors`), qm.WhereIn(`distributors.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load distributors")
	}

	var resultSlice []*Distributor
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice distributors")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on distributors")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for distributors")
	}

	if len(distributorAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByDistributors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &distributorR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByDistributors = append(local.R.CreatedByDistributors, foreign)
				if foreign.R == nil {
					foreign.R = &distributorR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadIssuedTokens allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadIssuedTokens(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`issued_tokens`), qm.WhereIn(`issued_tokens.user_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load issued_tokens")
	}

	var resultSlice []*IssuedToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice issued_tokens")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on issued_tokens")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for issued_tokens")
	}

	if len(issuedTokenAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssuedTokens = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &issuedTokenR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.IssuedTokens = append(local.R.IssuedTokens, foreign)
				if foreign.R == nil {
					foreign.R = &issuedTokenR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByOrders(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`orders`), qm.WhereIn(`orders.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orders")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if len(orderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByOrders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByOrders = append(local.R.CreatedByOrders, foreign)
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByPallets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByPallets(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`pallets`), qm.WhereIn(`pallets.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load pallets")
	}

	var resultSlice []*Pallet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice pallets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on pallets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for pallets")
	}

	if len(palletAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByPallets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &palletR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByPallets = append(local.R.CreatedByPallets, foreign)
				if foreign.R == nil {
					foreign.R = &palletR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByProducts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByProducts(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`products`), qm.WhereIn(`products.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load products")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice products")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for products")
	}

	if len(productAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByProducts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByProducts = append(local.R.CreatedByProducts, foreign)
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadReferredByReferrals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadReferredByReferrals(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`referrals`), qm.WhereIn(`referrals.referred_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referrals")
	}

	var resultSlice []*Referral
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referrals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referrals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referrals")
	}

	if len(referralAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReferredByReferrals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralR{}
			}
			foreign.R.ReferredBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ReferredByID) {
				local.R.ReferredByReferrals = append(local.R.ReferredByReferrals, foreign)
				if foreign.R == nil {
					foreign.R = &referralR{}
				}
				foreign.R.ReferredBy = local
				break
			}
		}
	}

	return nil
}

// LoadReferrals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadReferrals(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`referrals`), qm.WhereIn(`referrals.user_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load referrals")
	}

	var resultSlice []*Referral
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice referrals")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on referrals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for referrals")
	}

	if len(referralAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Referrals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &referralR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Referrals = append(local.R.Referrals, foreign)
				if foreign.R == nil {
					foreign.R = &referralR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByStockKeepingUnits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByStockKeepingUnits(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`stock_keeping_units`), qm.WhereIn(`stock_keeping_units.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load stock_keeping_units")
	}

	var resultSlice []*StockKeepingUnit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice stock_keeping_units")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on stock_keeping_units")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for stock_keeping_units")
	}

	if len(stockKeepingUnitAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByStockKeepingUnits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stockKeepingUnitR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CreatedByID {
				local.R.CreatedByStockKeepingUnits = append(local.R.CreatedByStockKeepingUnits, foreign)
				if foreign.R == nil {
					foreign.R = &stockKeepingUnitR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByTrackActions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByTrackActions(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`track_actions`), qm.WhereIn(`track_actions.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load track_actions")
	}

	var resultSlice []*TrackAction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice track_actions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on track_actions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for track_actions")
	}

	if len(trackActionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByTrackActions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &trackActionR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedByID) {
				local.R.CreatedByTrackActions = append(local.R.CreatedByTrackActions, foreign)
				if foreign.R == nil {
					foreign.R = &trackActionR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByTransactions(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`transactions`), qm.WhereIn(`transactions.created_by_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transactions")
	}

	var resultSlice []*Transaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transactions")
	}

	if len(transactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transactionR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedByID) {
				local.R.CreatedByTransactions = append(local.R.CreatedByTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &transactionR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadUserActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserActivities(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`user_activities`), qm.WhereIn(`user_activities.user_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_activities")
	}

	var resultSlice []*UserActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_activities")
	}

	if len(userActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserActivities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userActivityR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserActivities = append(local.R.UserActivities, foreign)
				if foreign.R == nil {
					foreign.R = &userActivityR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserLoyaltyActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserLoyaltyActivities(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`user_loyalty_activities`), qm.WhereIn(`user_loyalty_activities.user_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_loyalty_activities")
	}

	var resultSlice []*UserLoyaltyActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_loyalty_activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_loyalty_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_loyalty_activities")
	}

	if len(userLoyaltyActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserLoyaltyActivities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userLoyaltyActivityR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserLoyaltyActivities = append(local.R.UserLoyaltyActivities, foreign)
				if foreign.R == nil {
					foreign.R = &userLoyaltyActivityR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserTasks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserTasks(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		object = maybeUser.(*User)
	} else {
		slice = *maybeUser.(*[]*User)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`user_tasks`), qm.WhereIn(`user_tasks.user_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_tasks")
	}

	var resultSlice []*UserTask
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_tasks")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_tasks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_tasks")
	}

	if len(userTaskAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserTasks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userTaskR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserTasks = append(local.R.UserTasks, foreign)
				if foreign.R == nil {
					foreign.R = &userTaskR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// SetOrganisation of the user to the related item.
// Sets o.R.Organisation to related.
// Adds o to related.R.Users.
func (o *User) SetOrganisation(exec boil.Executor, insert bool, related *Organisation) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"organisation_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrganisationID, related.ID)
	if o.R == nil {
		o.R = &userR{
			Organisation: related,
		}
	} else {
		o.R.Organisation = related
	}

	if related.R == nil {
		related.R = &organisationR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// RemoveOrganisation relationship.
// Sets o.R.Organisation to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *User) RemoveOrganisation(exec boil.Executor, related *Organisation) error {
	var err error

	queries.SetScanner(&o.OrganisationID, nil)
	if _, err = o.Update(exec, boil.Whitelist("organisation_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Organisation = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Users {
		if queries.Equal(o.OrganisationID, ri.OrganisationID) {
			continue
		}

		ln := len(related.R.Users)
		if ln > 1 && i < ln-1 {
			related.R.Users[i] = related.R.Users[ln-1]
		}
		related.R.Users = related.R.Users[:ln-1]
		break
	}
	return nil
}

// SetRole of the user to the related item.
// Sets o.R.Role to related.
// Adds o to related.R.Users.
func (o *User) SetRole(exec boil.Executor, insert bool, related *Role) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"role_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RoleID = related.ID
	if o.R == nil {
		o.R = &userR{
			Role: related,
		}
	} else {
		o.R.Role = related
	}

	if related.R == nil {
		related.R = &roleR{
			Users: UserSlice{o},
		}
	} else {
		related.R.Users = append(related.R.Users, o)
	}

	return nil
}

// AddCreatedByCartons adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByCartons.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByCartons(exec boil.Executor, insert bool, related ...*Carton) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"cartons\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, cartonPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByCartons: related,
		}
	} else {
		o.R.CreatedByCartons = append(o.R.CreatedByCartons, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cartonR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByContainers adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByContainers.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByContainers(exec boil.Executor, insert bool, related ...*Container) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"containers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, containerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByContainers: related,
		}
	} else {
		o.R.CreatedByContainers = append(o.R.CreatedByContainers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &containerR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByContracts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByContracts.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByContracts(exec boil.Executor, insert bool, related ...*Contract) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"contracts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, contractPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByContracts: related,
		}
	} else {
		o.R.CreatedByContracts = append(o.R.CreatedByContracts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &contractR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByDistributors adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByDistributors.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByDistributors(exec boil.Executor, insert bool, related ...*Distributor) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"distributors\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, distributorPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByDistributors: related,
		}
	} else {
		o.R.CreatedByDistributors = append(o.R.CreatedByDistributors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &distributorR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddIssuedTokens adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.IssuedTokens.
// Sets related.R.User appropriately.
func (o *User) AddIssuedTokens(exec boil.Executor, insert bool, related ...*IssuedToken) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"issued_tokens\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, issuedTokenPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			IssuedTokens: related,
		}
	} else {
		o.R.IssuedTokens = append(o.R.IssuedTokens, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &issuedTokenR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCreatedByOrders adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByOrders.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByOrders(exec boil.Executor, insert bool, related ...*Order) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orders\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByOrders: related,
		}
	} else {
		o.R.CreatedByOrders = append(o.R.CreatedByOrders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByPallets adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByPallets.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByPallets(exec boil.Executor, insert bool, related ...*Pallet) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"pallets\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, palletPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByPallets: related,
		}
	} else {
		o.R.CreatedByPallets = append(o.R.CreatedByPallets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &palletR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByProducts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByProducts.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByProducts(exec boil.Executor, insert bool, related ...*Product) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"products\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, productPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByProducts: related,
		}
	} else {
		o.R.CreatedByProducts = append(o.R.CreatedByProducts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddReferredByReferrals adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ReferredByReferrals.
// Sets related.R.ReferredBy appropriately.
func (o *User) AddReferredByReferrals(exec boil.Executor, insert bool, related ...*Referral) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ReferredByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referrals\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"referred_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ReferredByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			ReferredByReferrals: related,
		}
	} else {
		o.R.ReferredByReferrals = append(o.R.ReferredByReferrals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralR{
				ReferredBy: o,
			}
		} else {
			rel.R.ReferredBy = o
		}
	}
	return nil
}

// SetReferredByReferrals removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ReferredBy's ReferredByReferrals accordingly.
// Replaces o.R.ReferredByReferrals with related.
// Sets related.R.ReferredBy's ReferredByReferrals accordingly.
func (o *User) SetReferredByReferrals(exec boil.Executor, insert bool, related ...*Referral) error {
	query := "update \"referrals\" set \"referred_by_id\" = null where \"referred_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ReferredByReferrals {
			queries.SetScanner(&rel.ReferredByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ReferredBy = nil
		}

		o.R.ReferredByReferrals = nil
	}
	return o.AddReferredByReferrals(exec, insert, related...)
}

// RemoveReferredByReferrals relationships from objects passed in.
// Removes related items from R.ReferredByReferrals (uses pointer comparison, removal does not keep order)
// Sets related.R.ReferredBy.
func (o *User) RemoveReferredByReferrals(exec boil.Executor, related ...*Referral) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ReferredByID, nil)
		if rel.R != nil {
			rel.R.ReferredBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("referred_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ReferredByReferrals {
			if rel != ri {
				continue
			}

			ln := len(o.R.ReferredByReferrals)
			if ln > 1 && i < ln-1 {
				o.R.ReferredByReferrals[i] = o.R.ReferredByReferrals[ln-1]
			}
			o.R.ReferredByReferrals = o.R.ReferredByReferrals[:ln-1]
			break
		}
	}

	return nil
}

// AddReferrals adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Referrals.
// Sets related.R.User appropriately.
func (o *User) AddReferrals(exec boil.Executor, insert bool, related ...*Referral) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"referrals\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, referralPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Referrals: related,
		}
	} else {
		o.R.Referrals = append(o.R.Referrals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &referralR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCreatedByStockKeepingUnits adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByStockKeepingUnits.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByStockKeepingUnits(exec boil.Executor, insert bool, related ...*StockKeepingUnit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CreatedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"stock_keeping_units\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, stockKeepingUnitPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CreatedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByStockKeepingUnits: related,
		}
	} else {
		o.R.CreatedByStockKeepingUnits = append(o.R.CreatedByStockKeepingUnits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stockKeepingUnitR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// AddCreatedByTrackActions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByTrackActions.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByTrackActions(exec boil.Executor, insert bool, related ...*TrackAction) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"track_actions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, trackActionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByTrackActions: related,
		}
	} else {
		o.R.CreatedByTrackActions = append(o.R.CreatedByTrackActions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &trackActionR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// SetCreatedByTrackActions removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedBy's CreatedByTrackActions accordingly.
// Replaces o.R.CreatedByTrackActions with related.
// Sets related.R.CreatedBy's CreatedByTrackActions accordingly.
func (o *User) SetCreatedByTrackActions(exec boil.Executor, insert bool, related ...*TrackAction) error {
	query := "update \"track_actions\" set \"created_by_id\" = null where \"created_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByTrackActions {
			queries.SetScanner(&rel.CreatedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedBy = nil
		}

		o.R.CreatedByTrackActions = nil
	}
	return o.AddCreatedByTrackActions(exec, insert, related...)
}

// RemoveCreatedByTrackActions relationships from objects passed in.
// Removes related items from R.CreatedByTrackActions (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedBy.
func (o *User) RemoveCreatedByTrackActions(exec boil.Executor, related ...*TrackAction) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedByID, nil)
		if rel.R != nil {
			rel.R.CreatedBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("created_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByTrackActions {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByTrackActions)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByTrackActions[i] = o.R.CreatedByTrackActions[ln-1]
			}
			o.R.CreatedByTrackActions = o.R.CreatedByTrackActions[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedByTransactions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByTransactions.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByTransactions(exec boil.Executor, insert bool, related ...*Transaction) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transactions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByTransactions: related,
		}
	} else {
		o.R.CreatedByTransactions = append(o.R.CreatedByTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transactionR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// SetCreatedByTransactions removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedBy's CreatedByTransactions accordingly.
// Replaces o.R.CreatedByTransactions with related.
// Sets related.R.CreatedBy's CreatedByTransactions accordingly.
func (o *User) SetCreatedByTransactions(exec boil.Executor, insert bool, related ...*Transaction) error {
	query := "update \"transactions\" set \"created_by_id\" = null where \"created_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByTransactions {
			queries.SetScanner(&rel.CreatedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedBy = nil
		}

		o.R.CreatedByTransactions = nil
	}
	return o.AddCreatedByTransactions(exec, insert, related...)
}

// RemoveCreatedByTransactions relationships from objects passed in.
// Removes related items from R.CreatedByTransactions (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedBy.
func (o *User) RemoveCreatedByTransactions(exec boil.Executor, related ...*Transaction) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedByID, nil)
		if rel.R != nil {
			rel.R.CreatedBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("created_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByTransactions {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByTransactions)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByTransactions[i] = o.R.CreatedByTransactions[ln-1]
			}
			o.R.CreatedByTransactions = o.R.CreatedByTransactions[:ln-1]
			break
		}
	}

	return nil
}

// AddUserActivities adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserActivities.
// Sets related.R.User appropriately.
func (o *User) AddUserActivities(exec boil.Executor, insert bool, related ...*UserActivity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userActivityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserActivities: related,
		}
	} else {
		o.R.UserActivities = append(o.R.UserActivities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userActivityR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserLoyaltyActivities adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserLoyaltyActivities.
// Sets related.R.User appropriately.
func (o *User) AddUserLoyaltyActivities(exec boil.Executor, insert bool, related ...*UserLoyaltyActivity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_loyalty_activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userLoyaltyActivityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserLoyaltyActivities: related,
		}
	} else {
		o.R.UserLoyaltyActivities = append(o.R.UserLoyaltyActivities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userLoyaltyActivityR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserTasks adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserTasks.
// Sets related.R.User appropriately.
func (o *User) AddUserTasks(exec boil.Executor, insert bool, related ...*UserTask) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_tasks\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userTaskPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserTasks: related,
		}
	} else {
		o.R.UserTasks = append(o.R.UserTasks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userTaskR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	return userQuery{NewQuery(mods...)}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(exec boil.Executor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, userObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "db: unable to select from users")
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("db: no users provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "db: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("db: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("db: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("db: no users provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("db: unable to upsert users, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "db: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("db: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by delete for users")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("db: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "db: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "db: failed to get rows affected by deleteall for users")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(exec boil.Executor) error {
	ret, err := FindUser(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "db: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "db: unable to check if users exists")
	}

	return exists, nil
}
