// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	db "genesis/db"

	graphql "genesis/graphql"

	mock "github.com/stretchr/testify/mock"

	sql "database/sql"

	uuid "github.com/gofrs/uuid"
)

// UserStorer is an autogenerated mock type for the UserStorer type
type UserStorer struct {
	mock.Mock
}

// All provides a mock function with given fields: txes
func (_m *UserStorer) All(txes ...*sql.Tx) (db.UserSlice, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 db.UserSlice
	if rf, ok := ret.Get(0).(func(...*sql.Tx) db.UserSlice); ok {
		r0 = rf(txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.UserSlice)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...*sql.Tx) error); ok {
		r1 = rf(txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeginTransaction provides a mock function with given fields:
func (_m *UserStorer) BeginTransaction() (*sql.Tx, error) {
	ret := _m.Called()

	var r0 *sql.Tx
	if rf, ok := ret.Get(0).(func() *sql.Tx); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Tx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: id, txes
func (_m *UserStorer) Get(id uuid.UUID, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(uuid.UUID, ...*sql.Tx) *db.User); ok {
		r0 = rf(id, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uuid.UUID, ...*sql.Tx) error); ok {
		r1 = rf(id, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByEmail provides a mock function with given fields: email, txes
func (_m *UserStorer) GetByEmail(email string, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, email)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(string, ...*sql.Tx) *db.User); ok {
		r0 = rf(email, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...*sql.Tx) error); ok {
		r1 = rf(email, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByOrganisation provides a mock function with given fields: orgID, txes
func (_m *UserStorer) GetByOrganisation(orgID uuid.UUID, txes ...*sql.Tx) (db.UserSlice, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, orgID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 db.UserSlice
	if rf, ok := ret.Get(0).(func(uuid.UUID, ...*sql.Tx) db.UserSlice); ok {
		r0 = rf(orgID, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.UserSlice)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uuid.UUID, ...*sql.Tx) error); ok {
		r1 = rf(orgID, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByResetToken provides a mock function with given fields: token, txes
func (_m *UserStorer) GetByResetToken(token string, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(string, ...*sql.Tx) *db.User); ok {
		r0 = rf(token, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...*sql.Tx) error); ok {
		r1 = rf(token, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByVerifyToken provides a mock function with given fields: token, txes
func (_m *UserStorer) GetByVerifyToken(token string, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(string, ...*sql.Tx) *db.User); ok {
		r0 = rf(token, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...*sql.Tx) error); ok {
		r1 = rf(token, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByWechatID provides a mock function with given fields: wechatID, txes
func (_m *UserStorer) GetByWechatID(wechatID string, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, wechatID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(string, ...*sql.Tx) *db.User); ok {
		r0 = rf(wechatID, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...*sql.Tx) error); ok {
		r1 = rf(wechatID, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMany provides a mock function with given fields: keys, txes
func (_m *UserStorer) GetMany(keys []string, txes ...*sql.Tx) (db.UserSlice, []error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, keys)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 db.UserSlice
	if rf, ok := ret.Get(0).(func([]string, ...*sql.Tx) db.UserSlice); ok {
		r0 = rf(keys, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.UserSlice)
		}
	}

	var r1 []error
	if rf, ok := ret.Get(1).(func([]string, ...*sql.Tx) []error); ok {
		r1 = rf(keys, txes...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]error)
		}
	}

	return r0, r1
}

// GetWithPermissions provides a mock function with given fields: id, txes
func (_m *UserStorer) GetWithPermissions(id uuid.UUID, txes ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(txes))
	for _i := range txes {
		_va[_i] = txes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(uuid.UUID, ...*sql.Tx) *db.User); ok {
		r0 = rf(id, txes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uuid.UUID, ...*sql.Tx) error); ok {
		r1 = rf(id, txes...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: u, tx
func (_m *UserStorer) Insert(u *db.User, tx ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(tx))
	for _i := range tx {
		_va[_i] = tx[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, u)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(*db.User, ...*sql.Tx) *db.User); ok {
		r0 = rf(u, tx...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*db.User, ...*sql.Tx) error); ok {
		r1 = rf(u, tx...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SearchSelect provides a mock function with given fields: search, limit, offset, consumer
func (_m *UserStorer) SearchSelect(search graphql.SearchFilter, limit int, offset int, consumer bool) ([]*db.User, int64, error) {
	ret := _m.Called(search, limit, offset, consumer)

	var r0 []*db.User
	if rf, ok := ret.Get(0).(func(graphql.SearchFilter, int, int, bool) []*db.User); ok {
		r0 = rf(search, limit, offset, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*db.User)
		}
	}

	var r1 int64
	if rf, ok := ret.Get(1).(func(graphql.SearchFilter, int, int, bool) int64); ok {
		r1 = rf(search, limit, offset, consumer)
	} else {
		r1 = ret.Get(1).(int64)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(graphql.SearchFilter, int, int, bool) error); ok {
		r2 = rf(search, limit, offset, consumer)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Update provides a mock function with given fields: u, tx
func (_m *UserStorer) Update(u *db.User, tx ...*sql.Tx) (*db.User, error) {
	_va := make([]interface{}, len(tx))
	for _i := range tx {
		_va[_i] = tx[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, u)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *db.User
	if rf, ok := ret.Get(0).(func(*db.User, ...*sql.Tx) *db.User); ok {
		r0 = rf(u, tx...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*db.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*db.User, ...*sql.Tx) error); ok {
		r1 = rf(u, tx...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
